#pragma config(Sensor, S1,     touchSensor,              sensorTouch)
#pragma config(Sensor, S2,     compassSensor,            sensorVirtualCompass)
#pragma config(Sensor, S3,     lightSensor,              sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,              sensorSONAR)
#pragma config(Motor,  motorA,          gripperMotor,       tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,         tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,          tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// This is for the NXT model, not TETRIX
//Sentry Level 2 Companion tables 2.24

void checkSonar()
	{
		int distance_to_obstacle = 15;
		int threshold = 5;

		//move foward while path is clear
		while (SensorValue(sonarSensor) > distance_to_obstacle)
			{
	 			motor[rightMotor] = 80;
	 			motor[leftMotor] = 80;
	 			wait1Msec(10);
			}

		//stop while object in path
		while (SensorValue(sonarSensor) <= distance_to_obstacle && SensorValue(sonarSensor) > threshold)
		{
			motor[rightMotor] = 0;
	 		motor[leftMotor] = 0;
		}
	}

void stopMotors()
{
		motor[rightMotor] = 0;
	 	motor[leftMotor] = 0;
	 	wait1Msec(500);
}

task main()
{
		int time = 750;

		while (1==1)
		{
		//clear encoder
		nMotorEncoder[rightMotor] = 0;

		//move to the end of long straight away
		while (nMotorEncoder[rightMotor] < 4200)
		{
			// checks sonar to "see" if there is an object in path--ranges greater than 250 cm produce a sonar error value of -1
			// therefore if -1 if found than object is assumed to not be in the path
			if (SensorValue[sonarSensor] == -1)
			{
				//do nothing
			}
			else
			{
				checkSonar();
			}

			motor[rightMotor] = 80;
			motor[leftMotor] = 80;
		}

		stopMotors();

		//Turn right
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
		wait1Msec(time);

		stopMotors();


		//clear encoder
		nMotorEncoder[rightMotor] = 0;

		//move to the end of short straight away
		while (nMotorEncoder[rightMotor] < 1700)
		{
			// checks sonar to "see" if there is an object in path--ranges greater than 250 cm produce a sonar error value of -1
			// therefore if -1 if found than object is assumed to not be in the path
			if (SensorValue[sonarSensor] == -1)
			{
				//do nothing
			}
			else
			{
				checkSonar();
			}

			motor[rightMotor] = 80;
			motor[leftMotor] = 80;
		}

		stopMotors();

		//Turn right
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
		wait1Msec(time);

		stopMotors();


		//clear encoder
		nMotorEncoder[rightMotor] = 0;

		//move to the end of long straight away
		while (nMotorEncoder[rightMotor] < 4200)
		{
			// checks sonar to "see" if there is an object in path--ranges greater than 250 cm produce a sonar error value of -1
			// therefore if -1 if found than object is assumed to not be in the path
			if (SensorValue[sonarSensor] == -1)
			{
				//do nothing
			}
			else
			{
				checkSonar();
			}

			motor[rightMotor] = 80;
			motor[leftMotor] = 80;
		}

		stopMotors();

		//Turn right
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
		wait1Msec(time);

		stopMotors();


		//clear encoder
		nMotorEncoder[rightMotor] = 0;

		//move to the end of short straight away
		while (nMotorEncoder[rightMotor] < 1700)
		{
			// checks sonar to "see" if there is an object in path--ranges greater than 250 cm produce a sonar error value of -1
			// therefore if -1 if found than object is assumed to not be in the path
			if (SensorValue[sonarSensor] == -1)
			{
				//do nothing
			}
			else
			{
				checkSonar();
			}

			motor[rightMotor] = 80;
			motor[leftMotor] = 80;
		}

		stopMotors();

		//Turn right
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
		wait1Msec(time);

		stopMotors();

	}
}


